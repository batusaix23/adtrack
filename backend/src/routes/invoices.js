const express = require('express');
const { query } = require('../config/database');
const { authenticateToken, authorizeRoles } = require('../middleware/auth');

const router = express.Router();

// ============================================
// INVOICE SETTINGS
// ============================================

router.get('/settings', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    let result = await query(
      'SELECT * FROM invoice_settings WHERE company_id = $1',
      [req.user.companyId]
    );

    if (result.rows.length === 0) {
      result = await query(
        `INSERT INTO invoice_settings (company_id) VALUES ($1) RETURNING *`,
        [req.user.companyId]
      );
    }

    res.json({ settings: result.rows[0] });
  } catch (error) {
    console.error('Error fetching invoice settings:', error);
    res.status(500).json({ error: 'Error cargando configuración' });
  }
});

router.put('/settings', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    const {
      invoicePrefix, estimatePrefix, defaultDueDays, defaultTaxRate,
      defaultTerms, defaultNotes, autoGenerateMonthly, autoGenerateDay,
      paymentInstructions, acceptSquare, acceptPaypal, squareLocationId, paypalClientId
    } = req.body;

    const result = await query(
      `UPDATE invoice_settings SET
        invoice_prefix = COALESCE($1, invoice_prefix),
        estimate_prefix = COALESCE($2, estimate_prefix),
        default_due_days = COALESCE($3, default_due_days),
        default_tax_rate = COALESCE($4, default_tax_rate),
        default_terms = COALESCE($5, default_terms),
        default_notes = COALESCE($6, default_notes),
        auto_generate_monthly = COALESCE($7, auto_generate_monthly),
        auto_generate_day = COALESCE($8, auto_generate_day),
        payment_instructions = COALESCE($9, payment_instructions),
        accept_square = COALESCE($10, accept_square),
        accept_paypal = COALESCE($11, accept_paypal),
        square_location_id = COALESCE($12, square_location_id),
        paypal_client_id = COALESCE($13, paypal_client_id),
        updated_at = CURRENT_TIMESTAMP
       WHERE company_id = $14
       RETURNING *`,
      [
        invoicePrefix, estimatePrefix, defaultDueDays, defaultTaxRate,
        defaultTerms, defaultNotes, autoGenerateMonthly, autoGenerateDay,
        paymentInstructions, acceptSquare, acceptPaypal, squareLocationId, paypalClientId,
        req.user.companyId
      ]
    );

    res.json({ settings: result.rows[0] });
  } catch (error) {
    console.error('Error updating invoice settings:', error);
    res.status(500).json({ error: 'Error actualizando configuración' });
  }
});

// ============================================
// INVOICE STATISTICS
// ============================================

router.get('/stats/summary', authenticateToken, async (req, res) => {
  try {
    const result = await query(
      `SELECT
        COUNT(*) FILTER (WHERE status = 'draft') as draft_count,
        COUNT(*) FILTER (WHERE status = 'sent') as sent_count,
        COUNT(*) FILTER (WHERE status = 'paid') as paid_count,
        COUNT(*) FILTER (WHERE status = 'overdue') as overdue_count,
        COUNT(*) FILTER (WHERE status = 'partial') as partial_count,
        COALESCE(SUM(balance_due) FILTER (WHERE status IN ('sent', 'overdue', 'partial')), 0) as total_outstanding,
        COALESCE(SUM(total) FILTER (WHERE status = 'paid' AND paid_date >= DATE_TRUNC('month', CURRENT_DATE)), 0) as paid_this_month,
        COALESCE(SUM(total) FILTER (WHERE issue_date >= DATE_TRUNC('month', CURRENT_DATE)), 0) as invoiced_this_month
       FROM invoices
       WHERE company_id = $1`,
      [req.user.companyId]
    );

    res.json({ stats: result.rows[0] });
  } catch (error) {
    console.error('Error fetching invoice stats:', error);
    res.status(500).json({ error: 'Error cargando estadísticas' });
  }
});

// ============================================
// LIST INVOICES
// ============================================

router.get('/', authenticateToken, async (req, res) => {
  try {
    const { status, clientId, startDate, endDate, page = 1, limit = 20 } = req.query;
    const offset = (page - 1) * limit;

    let whereClause = 'WHERE i.company_id = $1';
    const params = [req.user.companyId];
    let paramCount = 2;

    if (status) {
      whereClause += ` AND i.status = $${paramCount++}`;
      params.push(status);
    }

    if (clientId) {
      whereClause += ` AND i.client_id = $${paramCount++}`;
      params.push(clientId);
    }

    if (startDate) {
      whereClause += ` AND i.issue_date >= $${paramCount++}`;
      params.push(startDate);
    }

    if (endDate) {
      whereClause += ` AND i.issue_date <= $${paramCount++}`;
      params.push(endDate);
    }

    // Get count
    const countResult = await query(
      `SELECT COUNT(*) FROM invoices i ${whereClause}`,
      params
    );

    // Get invoices
    params.push(limit, offset);
    const result = await query(
      `SELECT i.*,
              c.first_name as client_first_name,
              c.last_name as client_last_name,
              c.company_name as client_company,
              c.email as client_email
       FROM invoices i
       JOIN clients c ON i.client_id = c.id
       ${whereClause}
       ORDER BY i.created_at DESC
       LIMIT $${paramCount++} OFFSET $${paramCount}`,
      params
    );

    res.json({
      invoices: result.rows,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(countResult.rows[0].count),
        totalPages: Math.ceil(countResult.rows[0].count / limit)
      }
    });
  } catch (error) {
    console.error('Error fetching invoices:', error);
    res.status(500).json({ error: 'Error cargando facturas' });
  }
});

// ============================================
// SINGLE INVOICE
// ============================================

router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const invoiceResult = await query(
      `SELECT i.*,
              c.first_name as client_first_name,
              c.last_name as client_last_name,
              c.company_name as client_company,
              c.email as client_email,
              c.phone as client_phone,
              c.address as client_address,
              c.city as client_city,
              c.state as client_state,
              c.zip_code as client_zip,
              comp.company_name as company_name,
              comp.address as company_address,
              comp.city as company_city,
              comp.state as company_state,
              comp.zip_code as company_zip,
              comp.phone as company_phone,
              comp.email as company_email,
              comp.logo_url as company_logo,
              comp.fei_ein as company_tax_id
       FROM invoices i
       JOIN clients c ON i.client_id = c.id
       JOIN companies comp ON i.company_id = comp.id
       WHERE i.id = $1 AND i.company_id = $2`,
      [req.params.id, req.user.companyId]
    );

    if (invoiceResult.rows.length === 0) {
      return res.status(404).json({ error: 'Factura no encontrada' });
    }

    const itemsResult = await query(
      'SELECT * FROM invoice_items WHERE invoice_id = $1 ORDER BY sort_order, created_at',
      [req.params.id]
    );

    const paymentsResult = await query(
      `SELECT * FROM payments WHERE invoice_id = $1 AND status = 'completed' ORDER BY payment_date DESC`,
      [req.params.id]
    );

    res.json({
      invoice: invoiceResult.rows[0],
      items: itemsResult.rows,
      payments: paymentsResult.rows
    });
  } catch (error) {
    console.error('Error fetching invoice:', error);
    res.status(500).json({ error: 'Error cargando factura' });
  }
});

// ============================================
// CREATE INVOICE
// ============================================

async function getNextInvoiceNumber(companyId) {
  const settingsResult = await query(
    'SELECT * FROM invoice_settings WHERE company_id = $1',
    [companyId]
  );

  let settings = settingsResult.rows[0];
  if (!settings) {
    const newSettings = await query(
      'INSERT INTO invoice_settings (company_id) VALUES ($1) RETURNING *',
      [companyId]
    );
    settings = newSettings.rows[0];
  }

  const invoiceNumber = `${settings.invoice_prefix}${String(settings.next_invoice_number).padStart(5, '0')}`;

  await query(
    'UPDATE invoice_settings SET next_invoice_number = next_invoice_number + 1 WHERE company_id = $1',
    [companyId]
  );

  return invoiceNumber;
}

router.post('/', authenticateToken, authorizeRoles('owner', 'admin', 'manager'), async (req, res) => {
  try {
    const {
      clientId, invoiceType = 'one_time', items, taxRate = 0, discountAmount = 0,
      notes, terms, dueDate, billingPeriodStart, billingPeriodEnd
    } = req.body;

    if (!clientId || !items || items.length === 0) {
      return res.status(400).json({ error: 'Cliente e items son requeridos' });
    }

    const invoiceNumber = await getNextInvoiceNumber(req.user.companyId);

    // Calculate totals
    const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxAmount = subtotal * (taxRate / 100);
    const total = subtotal + taxAmount - (discountAmount || 0);

    // Get default due days if not specified
    let finalDueDate = dueDate;
    if (!finalDueDate) {
      const settings = await query(
        'SELECT default_due_days FROM invoice_settings WHERE company_id = $1',
        [req.user.companyId]
      );
      const dueDays = settings.rows[0]?.default_due_days || 30;
      const date = new Date();
      date.setDate(date.getDate() + dueDays);
      finalDueDate = date.toISOString().split('T')[0];
    }

    // Insert invoice
    const invoiceResult = await query(
      `INSERT INTO invoices (
        company_id, client_id, invoice_number, invoice_type,
        subtotal, tax_rate, tax_amount, discount_amount, total, balance_due,
        due_date, notes, terms, billing_period_start, billing_period_end,
        status, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $9, $10, $11, $12, $13, $14, 'draft', $15)
      RETURNING *`,
      [
        req.user.companyId, clientId, invoiceNumber, invoiceType,
        subtotal, taxRate, taxAmount, discountAmount, total,
        finalDueDate, notes, terms, billingPeriodStart, billingPeriodEnd,
        req.user.userId
      ]
    );

    const invoice = invoiceResult.rows[0];

    // Insert items
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      await query(
        `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount, sort_order)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [invoice.id, item.description, item.quantity, item.unitPrice, item.quantity * item.unitPrice, i]
      );
    }

    res.status(201).json({ invoice });
  } catch (error) {
    console.error('Error creating invoice:', error);
    res.status(500).json({ error: 'Error creando factura' });
  }
});

// ============================================
// UPDATE INVOICE
// ============================================

router.put('/:id', authenticateToken, authorizeRoles('owner', 'admin', 'manager'), async (req, res) => {
  try {
    const { status, notes, terms, dueDate, items, taxRate, discountAmount } = req.body;

    // Check current status
    const existing = await query(
      'SELECT * FROM invoices WHERE id = $1 AND company_id = $2',
      [req.params.id, req.user.companyId]
    );

    if (existing.rows.length === 0) {
      return res.status(404).json({ error: 'Factura no encontrada' });
    }

    const currentInvoice = existing.rows[0];

    // Don't allow editing paid invoices
    if (currentInvoice.status === 'paid') {
      return res.status(400).json({ error: 'No se puede editar una factura pagada' });
    }

    // If items provided, recalculate totals
    let subtotal = currentInvoice.subtotal;
    let taxAmount = currentInvoice.tax_amount;
    let total = currentInvoice.total;
    let finalTaxRate = taxRate !== undefined ? taxRate : currentInvoice.tax_rate;
    let finalDiscount = discountAmount !== undefined ? discountAmount : currentInvoice.discount_amount;

    if (items && items.length > 0) {
      // Delete existing items and recreate
      await query('DELETE FROM invoice_items WHERE invoice_id = $1', [req.params.id]);

      subtotal = 0;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const amount = item.quantity * item.unitPrice;
        subtotal += amount;
        await query(
          `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount, sort_order)
           VALUES ($1, $2, $3, $4, $5, $6)`,
          [req.params.id, item.description, item.quantity, item.unitPrice, amount, i]
        );
      }

      taxAmount = subtotal * (finalTaxRate / 100);
      total = subtotal + taxAmount - finalDiscount;
    }

    // Update invoice
    let sentAt = currentInvoice.sent_at;
    if (status === 'sent' && !currentInvoice.sent_at) {
      sentAt = new Date();
    }

    const result = await query(
      `UPDATE invoices SET
        status = COALESCE($1, status),
        notes = COALESCE($2, notes),
        terms = COALESCE($3, terms),
        due_date = COALESCE($4, due_date),
        subtotal = $5,
        tax_rate = $6,
        tax_amount = $7,
        discount_amount = $8,
        total = $9,
        balance_due = $9 - amount_paid,
        sent_at = $10,
        updated_at = CURRENT_TIMESTAMP
       WHERE id = $11 AND company_id = $12
       RETURNING *`,
      [
        status, notes, terms, dueDate,
        subtotal, finalTaxRate, taxAmount, finalDiscount, total,
        sentAt, req.params.id, req.user.companyId
      ]
    );

    res.json({ invoice: result.rows[0] });
  } catch (error) {
    console.error('Error updating invoice:', error);
    res.status(500).json({ error: 'Error actualizando factura' });
  }
});

// ============================================
// SEND INVOICE
// ============================================

router.post('/:id/send', authenticateToken, authorizeRoles('owner', 'admin', 'manager'), async (req, res) => {
  try {
    const { via = 'email' } = req.body; // email, whatsapp, sms

    const result = await query(
      `UPDATE invoices SET
        status = 'sent',
        sent_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
       WHERE id = $1 AND company_id = $2 AND status = 'draft'
       RETURNING *`,
      [req.params.id, req.user.companyId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Factura no encontrada o ya enviada' });
    }

    // TODO: Actually send email/whatsapp/sms

    res.json({ success: true, invoice: result.rows[0] });
  } catch (error) {
    console.error('Error sending invoice:', error);
    res.status(500).json({ error: 'Error enviando factura' });
  }
});

// ============================================
// PAYMENTS
// ============================================

router.post('/:id/payment', authenticateToken, authorizeRoles('owner', 'admin', 'manager'), async (req, res) => {
  try {
    const { amount, paymentMethod, referenceNumber, notes, paymentDate } = req.body;

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Monto de pago requerido' });
    }

    // Get current invoice
    const invoiceResult = await query(
      'SELECT * FROM invoices WHERE id = $1 AND company_id = $2',
      [req.params.id, req.user.companyId]
    );

    if (invoiceResult.rows.length === 0) {
      return res.status(404).json({ error: 'Factura no encontrada' });
    }

    const invoice = invoiceResult.rows[0];

    if (invoice.status === 'paid') {
      return res.status(400).json({ error: 'Factura ya está pagada' });
    }

    // Record payment
    const paymentResult = await query(
      `INSERT INTO payments (
        company_id, client_id, invoice_id, amount, payment_method,
        reference_number, notes, payment_date, status, recorded_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'completed', $9)
      RETURNING *`,
      [
        req.user.companyId, invoice.client_id, req.params.id, amount,
        paymentMethod || 'cash', referenceNumber, notes,
        paymentDate || new Date(), req.user.userId
      ]
    );

    // Update invoice
    const newAmountPaid = Number(invoice.amount_paid) + Number(amount);
    const newBalanceDue = Number(invoice.total) - newAmountPaid;
    let newStatus = invoice.status;
    let paidDate = null;

    if (newBalanceDue <= 0) {
      newStatus = 'paid';
      paidDate = new Date();
    } else if (newAmountPaid > 0) {
      newStatus = 'partial';
    }

    const updatedInvoice = await query(
      `UPDATE invoices SET
        amount_paid = $1,
        balance_due = $2,
        status = $3,
        paid_date = COALESCE($4, paid_date),
        updated_at = CURRENT_TIMESTAMP
       WHERE id = $5
       RETURNING *`,
      [newAmountPaid, Math.max(0, newBalanceDue), newStatus, paidDate, req.params.id]
    );

    res.json({
      invoice: updatedInvoice.rows[0],
      payment: paymentResult.rows[0]
    });
  } catch (error) {
    console.error('Error recording payment:', error);
    res.status(500).json({ error: 'Error registrando pago' });
  }
});

// Get payments for an invoice
router.get('/:id/payments', authenticateToken, async (req, res) => {
  try {
    const result = await query(
      `SELECT p.*, u.first_name as recorded_by_first, u.last_name as recorded_by_last
       FROM payments p
       LEFT JOIN users u ON p.recorded_by = u.id
       WHERE p.invoice_id = $1 AND p.company_id = $2
       ORDER BY p.payment_date DESC`,
      [req.params.id, req.user.companyId]
    );

    res.json({ payments: result.rows });
  } catch (error) {
    console.error('Error fetching payments:', error);
    res.status(500).json({ error: 'Error cargando pagos' });
  }
});

// ============================================
// RECURRING INVOICES
// ============================================

// Generate invoice from client's monthly service cost
router.post('/generate/:clientId', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    const { billingPeriodStart, billingPeriodEnd, includeStabilizer = false } = req.body;

    // Get client with service info
    const clientResult = await query(
      `SELECT c.*, t.first_name as tech_first, t.last_name as tech_last
       FROM clients c
       LEFT JOIN technicians t ON c.assigned_technician_id = t.id
       WHERE c.id = $1 AND c.company_id = $2`,
      [req.params.clientId, req.user.companyId]
    );

    if (clientResult.rows.length === 0) {
      return res.status(404).json({ error: 'Cliente no encontrado' });
    }

    const client = clientResult.rows[0];

    if (!client.monthly_service_cost || client.monthly_service_cost <= 0) {
      return res.status(400).json({ error: 'Cliente no tiene costo de servicio configurado' });
    }

    // Get settings
    const settingsResult = await query(
      'SELECT * FROM invoice_settings WHERE company_id = $1',
      [req.user.companyId]
    );
    const settings = settingsResult.rows[0] || { default_tax_rate: 0, default_due_days: 30 };

    // Build items
    const items = [{
      description: `Servicio de mantenimiento de piscina - ${client.service_frequency || '1x por semana'}`,
      quantity: 1,
      unitPrice: Number(client.monthly_service_cost)
    }];

    // Check if stabilizer should be included
    if (includeStabilizer && client.stabilizer_cost && client.stabilizer_cost > 0) {
      items.push({
        description: 'Estabilizador',
        quantity: 1,
        unitPrice: Number(client.stabilizer_cost)
      });
    }

    // Get client rates
    const ratesResult = await query(
      `SELECT * FROM client_rates WHERE client_id = $1 AND is_active = true`,
      [req.params.clientId]
    );

    for (const rate of ratesResult.rows) {
      if (rate.frequency === 'monthly') {
        items.push({
          description: rate.name,
          quantity: 1,
          unitPrice: Number(rate.amount)
        });
      }
    }

    const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxRate = Number(settings.default_tax_rate) || 0;
    const taxAmount = subtotal * (taxRate / 100);
    const total = subtotal + taxAmount;

    const invoiceNumber = await getNextInvoiceNumber(req.user.companyId);

    // Calculate dates
    const now = new Date();
    const periodStart = billingPeriodStart || new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
    const periodEnd = billingPeriodEnd || new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0];

    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + (settings.default_due_days || 30));

    // Create invoice
    const invoiceResult = await query(
      `INSERT INTO invoices (
        company_id, client_id, invoice_number, invoice_type,
        subtotal, tax_rate, tax_amount, total, balance_due,
        due_date, billing_period_start, billing_period_end,
        terms, notes, status, created_by
      ) VALUES ($1, $2, $3, 'recurring', $4, $5, $6, $7, $7, $8, $9, $10, $11, $12, 'draft', $13)
      RETURNING *`,
      [
        req.user.companyId, req.params.clientId, invoiceNumber,
        subtotal, taxRate, taxAmount, total,
        dueDate.toISOString().split('T')[0], periodStart, periodEnd,
        settings.default_terms, settings.default_notes, req.user.userId
      ]
    );

    const invoice = invoiceResult.rows[0];

    // Insert items
    for (let i = 0; i < items.length; i++) {
      await query(
        `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount, sort_order)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [invoice.id, items[i].description, items[i].quantity, items[i].unitPrice, items[i].quantity * items[i].unitPrice, i]
      );
    }

    res.status(201).json({ invoice, items });
  } catch (error) {
    console.error('Error generating invoice:', error);
    res.status(500).json({ error: 'Error generando factura' });
  }
});

// Bulk generate monthly invoices
router.post('/generate-monthly', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    const { autoSend = false } = req.body;

    // Get billing period
    const now = new Date();
    const billingPeriodStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
    const billingPeriodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0];

    // Get all active clients with monthly service cost
    const clientsResult = await query(
      `SELECT c.*
       FROM clients c
       WHERE c.company_id = $1 AND c.is_active = true AND c.status = 'active'
         AND c.monthly_service_cost > 0`,
      [req.user.companyId]
    );

    const results = [];

    for (const client of clientsResult.rows) {
      try {
        // Check if invoice already exists for this period
        const existing = await query(
          `SELECT id FROM invoices
           WHERE client_id = $1 AND company_id = $2
           AND billing_period_start = $3`,
          [client.id, req.user.companyId, billingPeriodStart]
        );

        if (existing.rows.length > 0) {
          results.push({
            clientId: client.id,
            clientName: `${client.first_name} ${client.last_name}`,
            status: 'skipped',
            reason: 'Factura ya existe para este período'
          });
          continue;
        }

        // Get settings
        const settingsResult = await query(
          'SELECT * FROM invoice_settings WHERE company_id = $1',
          [req.user.companyId]
        );
        const settings = settingsResult.rows[0] || { default_tax_rate: 0, default_due_days: 30 };

        // Build items
        const items = [{
          description: `Servicio de mantenimiento - ${client.service_frequency || 'mensual'}`,
          quantity: 1,
          unitPrice: Number(client.monthly_service_cost)
        }];

        // Check stabilizer
        if (client.stabilizer_cost && client.stabilizer_cost > 0 && client.stabilizer_frequency_months) {
          // Check if stabilizer is due this month
          const lastStabilizerResult = await query(
            `SELECT MAX(i.issue_date) as last_date
             FROM invoices i
             JOIN invoice_items ii ON ii.invoice_id = i.id
             WHERE i.client_id = $1 AND ii.description ILIKE '%estabilizador%'`,
            [client.id]
          );

          const lastDate = lastStabilizerResult.rows[0]?.last_date;
          const monthsSinceLast = lastDate
            ? Math.floor((now.getTime() - new Date(lastDate).getTime()) / (30 * 24 * 60 * 60 * 1000))
            : client.stabilizer_frequency_months;

          if (monthsSinceLast >= client.stabilizer_frequency_months) {
            items.push({
              description: 'Estabilizador',
              quantity: 1,
              unitPrice: Number(client.stabilizer_cost)
            });
          }
        }

        // Get client rates
        const ratesResult = await query(
          `SELECT * FROM client_rates WHERE client_id = $1 AND is_active = true AND frequency = 'monthly'`,
          [client.id]
        );

        for (const rate of ratesResult.rows) {
          items.push({
            description: rate.name,
            quantity: 1,
            unitPrice: Number(rate.amount)
          });
        }

        const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
        const taxRate = Number(settings.default_tax_rate) || 0;
        const taxAmount = subtotal * (taxRate / 100);
        const total = subtotal + taxAmount;

        const invoiceNumber = await getNextInvoiceNumber(req.user.companyId);

        const dueDate = new Date();
        dueDate.setDate(dueDate.getDate() + (settings.default_due_days || 30));

        // Create invoice
        const invoiceResult = await query(
          `INSERT INTO invoices (
            company_id, client_id, invoice_number, invoice_type,
            subtotal, tax_rate, tax_amount, total, balance_due,
            due_date, billing_period_start, billing_period_end,
            status, created_by
          ) VALUES ($1, $2, $3, 'recurring', $4, $5, $6, $7, $7, $8, $9, $10, $11, $12)
          RETURNING *`,
          [
            req.user.companyId, client.id, invoiceNumber,
            subtotal, taxRate, taxAmount, total,
            dueDate.toISOString().split('T')[0], billingPeriodStart, billingPeriodEnd,
            autoSend ? 'sent' : 'draft', req.user.userId
          ]
        );

        const invoice = invoiceResult.rows[0];

        // Insert items
        for (let i = 0; i < items.length; i++) {
          await query(
            `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount, sort_order)
             VALUES ($1, $2, $3, $4, $5, $6)`,
            [invoice.id, items[i].description, items[i].quantity, items[i].unitPrice, items[i].quantity * items[i].unitPrice, i]
          );
        }

        if (autoSend) {
          await query(
            `UPDATE invoices SET sent_at = CURRENT_TIMESTAMP WHERE id = $1`,
            [invoice.id]
          );
        }

        results.push({
          clientId: client.id,
          clientName: `${client.first_name} ${client.last_name}`,
          status: 'created',
          invoiceNumber,
          total
        });
      } catch (err) {
        results.push({
          clientId: client.id,
          clientName: `${client.first_name} ${client.last_name}`,
          status: 'error',
          error: err.message
        });
      }
    }

    res.json({
      results,
      summary: {
        total: results.length,
        created: results.filter(r => r.status === 'created').length,
        skipped: results.filter(r => r.status === 'skipped').length,
        errors: results.filter(r => r.status === 'error').length
      }
    });
  } catch (error) {
    console.error('Error generating monthly invoices:', error);
    res.status(500).json({ error: 'Error generando facturas mensuales' });
  }
});

// ============================================
// MARK OVERDUE
// ============================================

router.post('/mark-overdue', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    const today = new Date().toISOString().split('T')[0];

    const result = await query(
      `UPDATE invoices SET
        status = 'overdue',
        updated_at = CURRENT_TIMESTAMP
       WHERE company_id = $1
         AND status = 'sent'
         AND due_date < $2
       RETURNING id`,
      [req.user.companyId, today]
    );

    res.json({
      success: true,
      markedOverdue: result.rows.length
    });
  } catch (error) {
    console.error('Error marking overdue:', error);
    res.status(500).json({ error: 'Error marcando vencidas' });
  }
});

// ============================================
// DELETE INVOICE
// ============================================

router.delete('/:id', authenticateToken, authorizeRoles('owner', 'admin'), async (req, res) => {
  try {
    // Only allow deleting draft invoices or unpaid
    const result = await query(
      `DELETE FROM invoices
       WHERE id = $1 AND company_id = $2 AND status IN ('draft', 'sent')
       RETURNING id`,
      [req.params.id, req.user.companyId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Factura no encontrada o no se puede eliminar' });
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting invoice:', error);
    res.status(500).json({ error: 'Error eliminando factura' });
  }
});

module.exports = router;
