const express = require('express');
const { query } = require('../config/database');
const authenticate = require('../middleware/authenticate');
const { authorizeRoles } = require('../middleware/authorize');

const router = express.Router();

// Get invoice settings
router.get('/settings', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    let result = await query(
      'SELECT * FROM invoice_settings WHERE company_id = $1',
      [req.user.company_id]
    );

    if (result.rows.length === 0) {
      // Create default settings
      result = await query(
        `INSERT INTO invoice_settings (company_id)
         VALUES ($1)
         RETURNING *`,
        [req.user.company_id]
      );
    }

    res.json({ settings: result.rows[0] });
  } catch (error) {
    next(error);
  }
});

// Update invoice settings
router.put('/settings', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const {
      invoicePrefix,
      defaultDueDays,
      defaultTaxRate,
      defaultTerms,
      defaultNotes,
      autoGenerateMonthly,
      autoGenerateDay
    } = req.body;

    const result = await query(
      `UPDATE invoice_settings
       SET invoice_prefix = COALESCE($1, invoice_prefix),
           default_due_days = COALESCE($2, default_due_days),
           default_tax_rate = COALESCE($3, default_tax_rate),
           default_terms = COALESCE($4, default_terms),
           default_notes = COALESCE($5, default_notes),
           auto_generate_monthly = COALESCE($6, auto_generate_monthly),
           auto_generate_day = COALESCE($7, auto_generate_day),
           updated_at = CURRENT_TIMESTAMP
       WHERE company_id = $8
       RETURNING *`,
      [invoicePrefix, defaultDueDays, defaultTaxRate, defaultTerms, defaultNotes, autoGenerateMonthly, autoGenerateDay, req.user.company_id]
    );

    res.json({ settings: result.rows[0] });
  } catch (error) {
    next(error);
  }
});

// Get all invoices
router.get('/', authenticate, async (req, res, next) => {
  try {
    const { status, clientId, startDate, endDate } = req.query;

    let sql = `
      SELECT i.*,
             c.name as client_name,
             c.last_name as client_last_name,
             c.email as client_email
      FROM invoices i
      JOIN clients c ON i.client_id = c.id
      WHERE i.company_id = $1
    `;
    const params = [req.user.company_id];
    let paramIndex = 2;

    if (status) {
      sql += ` AND i.status = $${paramIndex}`;
      params.push(status);
      paramIndex++;
    }

    if (clientId) {
      sql += ` AND i.client_id = $${paramIndex}`;
      params.push(clientId);
      paramIndex++;
    }

    if (startDate) {
      sql += ` AND i.issue_date >= $${paramIndex}`;
      params.push(startDate);
      paramIndex++;
    }

    if (endDate) {
      sql += ` AND i.issue_date <= $${paramIndex}`;
      params.push(endDate);
      paramIndex++;
    }

    sql += ' ORDER BY i.created_at DESC';

    const result = await query(sql, params);
    res.json({ invoices: result.rows });
  } catch (error) {
    next(error);
  }
});

// Get single invoice with items
router.get('/:id', authenticate, async (req, res, next) => {
  try {
    const invoiceResult = await query(
      `SELECT i.*,
              c.name as client_name,
              c.last_name as client_last_name,
              c.email as client_email,
              c.address as client_address,
              c.city as client_city,
              c.state as client_state,
              c.zip_code as client_zip,
              c.phone as client_phone,
              comp.name as company_name,
              comp.address as company_address,
              comp.phone as company_phone,
              comp.email as company_email,
              comp.logo_url as company_logo
       FROM invoices i
       JOIN clients c ON i.client_id = c.id
       JOIN companies comp ON i.company_id = comp.id
       WHERE i.id = $1 AND i.company_id = $2`,
      [req.params.id, req.user.company_id]
    );

    if (invoiceResult.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    const itemsResult = await query(
      'SELECT * FROM invoice_items WHERE invoice_id = $1 ORDER BY created_at',
      [req.params.id]
    );

    const paymentsResult = await query(
      'SELECT * FROM payments WHERE invoice_id = $1 ORDER BY payment_date DESC',
      [req.params.id]
    );

    res.json({
      invoice: invoiceResult.rows[0],
      items: itemsResult.rows,
      payments: paymentsResult.rows
    });
  } catch (error) {
    next(error);
  }
});

// Generate next invoice number
async function getNextInvoiceNumber(companyId) {
  const settingsResult = await query(
    'SELECT * FROM invoice_settings WHERE company_id = $1',
    [companyId]
  );

  let settings = settingsResult.rows[0];
  if (!settings) {
    const newSettings = await query(
      'INSERT INTO invoice_settings (company_id) VALUES ($1) RETURNING *',
      [companyId]
    );
    settings = newSettings.rows[0];
  }

  const invoiceNumber = `${settings.invoice_prefix}${String(settings.next_invoice_number).padStart(5, '0')}`;

  await query(
    'UPDATE invoice_settings SET next_invoice_number = next_invoice_number + 1 WHERE company_id = $1',
    [companyId]
  );

  return invoiceNumber;
}

// Create invoice
router.post('/', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const {
      clientId,
      items,
      taxRate = 0,
      notes,
      terms,
      dueDate,
      billingPeriodStart,
      billingPeriodEnd
    } = req.body;

    if (!clientId || !items || items.length === 0) {
      return res.status(400).json({ error: 'Client and at least one item are required' });
    }

    const invoiceNumber = await getNextInvoiceNumber(req.user.company_id);

    // Calculate totals
    const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxAmount = subtotal * (taxRate / 100);
    const total = subtotal + taxAmount;

    // Get default due days if not specified
    let finalDueDate = dueDate;
    if (!finalDueDate) {
      const settings = await query(
        'SELECT default_due_days FROM invoice_settings WHERE company_id = $1',
        [req.user.company_id]
      );
      const dueDays = settings.rows[0]?.default_due_days || 30;
      const date = new Date();
      date.setDate(date.getDate() + dueDays);
      finalDueDate = date.toISOString().split('T')[0];
    }

    // Insert invoice
    const invoiceResult = await query(
      `INSERT INTO invoices (
        company_id, client_id, invoice_number, subtotal, tax_rate, tax_amount,
        total, balance_due, due_date, notes, terms, billing_period_start, billing_period_end
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *`,
      [
        req.user.company_id, clientId, invoiceNumber, subtotal, taxRate, taxAmount,
        total, total, finalDueDate, notes, terms, billingPeriodStart, billingPeriodEnd
      ]
    );

    const invoice = invoiceResult.rows[0];

    // Insert items
    for (const item of items) {
      await query(
        `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount, rate_id)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [invoice.id, item.description, item.quantity, item.unitPrice, item.quantity * item.unitPrice, item.rateId]
      );
    }

    res.status(201).json({ invoice });
  } catch (error) {
    next(error);
  }
});

// Generate invoice from client's assigned service items
router.post('/generate/:clientId', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const { billingPeriodStart, billingPeriodEnd, frequency = 'monthly' } = req.body;

    // Get active recurring items for client
    const itemsResult = await query(
      `SELECT csi.*, si.name, si.description as item_description, si.base_price, si.unit, si.tax_rate as item_tax_rate
       FROM client_service_items csi
       JOIN service_items si ON csi.service_item_id = si.id
       WHERE csi.client_id = $1 AND csi.company_id = $2
         AND csi.is_active = true AND csi.is_recurring = true
         AND (csi.frequency = $3 OR $3 = 'all')`,
      [req.params.clientId, req.user.company_id, frequency]
    );

    if (itemsResult.rows.length === 0) {
      return res.status(400).json({ error: 'No active recurring items found for this client' });
    }

    // Get settings
    const settingsResult = await query(
      'SELECT * FROM invoice_settings WHERE company_id = $1',
      [req.user.company_id]
    );
    const settings = settingsResult.rows[0] || { default_tax_rate: 0, default_due_days: 30 };

    // Calculate items
    const invoiceItems = itemsResult.rows.map(item => ({
      description: item.name + (item.notes ? ` - ${item.notes}` : ''),
      quantity: Number(item.quantity),
      unitPrice: Number(item.custom_price || item.base_price),
      serviceItemId: item.service_item_id
    }));

    const subtotal = invoiceItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxRate = Number(settings.default_tax_rate) || 0;
    const taxAmount = subtotal * (taxRate / 100);
    const total = subtotal + taxAmount;

    const invoiceNumber = await getNextInvoiceNumber(req.user.company_id);

    // Calculate due date
    const date = new Date();
    date.setDate(date.getDate() + (settings.default_due_days || 30));
    const dueDate = date.toISOString().split('T')[0];

    // Billing period defaults to current month
    const periodStart = billingPeriodStart || new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0];
    const periodEnd = billingPeriodEnd || new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0).toISOString().split('T')[0];

    // Insert invoice
    const invoiceResult = await query(
      `INSERT INTO invoices (
        company_id, client_id, invoice_number, subtotal, tax_rate, tax_amount,
        total, balance_due, due_date, billing_period_start, billing_period_end
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *`,
      [
        req.user.company_id, req.params.clientId, invoiceNumber, subtotal,
        taxRate, taxAmount, total, total, dueDate, periodStart, periodEnd
      ]
    );

    const invoice = invoiceResult.rows[0];

    // Insert items
    for (const item of invoiceItems) {
      await query(
        `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount)
         VALUES ($1, $2, $3, $4, $5)`,
        [invoice.id, item.description, item.quantity, item.unitPrice, item.quantity * item.unitPrice]
      );
    }

    res.status(201).json({ invoice });
  } catch (error) {
    next(error);
  }
});

// Generate invoices for all clients with active recurring items
router.post('/generate-monthly', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    // Get all clients with active recurring service items
    const clientsResult = await query(
      `SELECT DISTINCT c.id, c.name
       FROM clients c
       JOIN client_service_items csi ON c.id = csi.client_id
       WHERE c.company_id = $1 AND c.is_active = true
         AND csi.is_active = true AND csi.is_recurring = true
         AND csi.frequency = 'monthly'`,
      [req.user.company_id]
    );

    const billingPeriodStart = new Date();
    billingPeriodStart.setDate(1);
    const billingPeriodEnd = new Date(billingPeriodStart);
    billingPeriodEnd.setMonth(billingPeriodEnd.getMonth() + 1);
    billingPeriodEnd.setDate(0);

    const results = [];

    for (const client of clientsResult.rows) {
      try {
        // Check if invoice already exists for this period
        const existingInvoice = await query(
          `SELECT id FROM invoices
           WHERE client_id = $1 AND company_id = $2
           AND billing_period_start = $3`,
          [client.id, req.user.company_id, billingPeriodStart.toISOString().split('T')[0]]
        );

        if (existingInvoice.rows.length > 0) {
          results.push({ clientId: client.id, clientName: client.name, status: 'skipped', reason: 'Invoice already exists' });
          continue;
        }

        // Get active recurring items for client
        const itemsResult = await query(
          `SELECT csi.*, si.name, si.base_price
           FROM client_service_items csi
           JOIN service_items si ON csi.service_item_id = si.id
           WHERE csi.client_id = $1 AND csi.company_id = $2
             AND csi.is_active = true AND csi.is_recurring = true
             AND csi.frequency = 'monthly'`,
          [client.id, req.user.company_id]
        );

        if (itemsResult.rows.length === 0) continue;

        // Get settings
        const settingsResult = await query(
          'SELECT * FROM invoice_settings WHERE company_id = $1',
          [req.user.company_id]
        );
        const settings = settingsResult.rows[0] || { default_tax_rate: 0, default_due_days: 30 };

        // Calculate items
        const invoiceItems = itemsResult.rows.map(item => ({
          description: item.name + (item.notes ? ` - ${item.notes}` : ''),
          quantity: Number(item.quantity),
          unitPrice: Number(item.custom_price || item.base_price)
        }));

        const subtotal = invoiceItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
        const taxRate = Number(settings.default_tax_rate) || 0;
        const taxAmount = subtotal * (taxRate / 100);
        const total = subtotal + taxAmount;

        const invoiceNumber = await getNextInvoiceNumber(req.user.company_id);

        const date = new Date();
        date.setDate(date.getDate() + (settings.default_due_days || 30));
        const dueDate = date.toISOString().split('T')[0];

        // Insert invoice
        const invoiceResult = await query(
          `INSERT INTO invoices (
            company_id, client_id, invoice_number, subtotal, tax_rate, tax_amount,
            total, balance_due, due_date, billing_period_start, billing_period_end
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
          RETURNING *`,
          [
            req.user.company_id, client.id, invoiceNumber, subtotal,
            taxRate, taxAmount, total, total, dueDate,
            billingPeriodStart.toISOString().split('T')[0],
            billingPeriodEnd.toISOString().split('T')[0]
          ]
        );

        // Insert items
        for (const item of invoiceItems) {
          await query(
            `INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, amount)
             VALUES ($1, $2, $3, $4, $5)`,
            [invoiceResult.rows[0].id, item.description, item.quantity, item.unitPrice, item.quantity * item.unitPrice]
          );
        }

        results.push({ clientId: client.id, clientName: client.name, status: 'created', invoiceNumber });
      } catch (err) {
        results.push({ clientId: client.id, clientName: client.name, status: 'error', error: err.message });
      }
    }

    res.json({ results, totalGenerated: results.filter(r => r.status === 'created').length });
  } catch (error) {
    next(error);
  }
});

// Update invoice
router.put('/:id', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const { status, notes, terms, dueDate } = req.body;

    let sentAt = null;
    if (status === 'sent') {
      sentAt = new Date();
    }

    const result = await query(
      `UPDATE invoices
       SET status = COALESCE($1, status),
           notes = COALESCE($2, notes),
           terms = COALESCE($3, terms),
           due_date = COALESCE($4, due_date),
           sent_at = COALESCE($5, sent_at),
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $6 AND company_id = $7
       RETURNING *`,
      [status, notes, terms, dueDate, sentAt, req.params.id, req.user.company_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json({ invoice: result.rows[0] });
  } catch (error) {
    next(error);
  }
});

// Record payment
router.post('/:id/payment', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const { amount, paymentMethod, paymentReference, notes, paymentDate } = req.body;

    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Valid payment amount is required' });
    }

    // Get current invoice
    const invoiceResult = await query(
      'SELECT * FROM invoices WHERE id = $1 AND company_id = $2',
      [req.params.id, req.user.company_id]
    );

    if (invoiceResult.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    const invoice = invoiceResult.rows[0];

    // Record payment
    await query(
      `INSERT INTO payments (company_id, invoice_id, amount, payment_method, payment_reference, notes, payment_date)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [req.user.company_id, req.params.id, amount, paymentMethod, paymentReference, notes, paymentDate || new Date()]
    );

    // Update invoice
    const newAmountPaid = Number(invoice.amount_paid) + Number(amount);
    const newBalanceDue = Number(invoice.total) - newAmountPaid;
    const newStatus = newBalanceDue <= 0 ? 'paid' : invoice.status;
    const paidDate = newBalanceDue <= 0 ? new Date() : null;

    const updatedInvoice = await query(
      `UPDATE invoices
       SET amount_paid = $1,
           balance_due = $2,
           status = $3,
           paid_date = COALESCE($4, paid_date),
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $5
       RETURNING *`,
      [newAmountPaid, Math.max(0, newBalanceDue), newStatus, paidDate, req.params.id]
    );

    res.json({ invoice: updatedInvoice.rows[0] });
  } catch (error) {
    next(error);
  }
});

// Delete invoice
router.delete('/:id', authenticate, authorizeRoles('owner', 'admin'), async (req, res, next) => {
  try {
    const result = await query(
      'DELETE FROM invoices WHERE id = $1 AND company_id = $2 RETURNING id',
      [req.params.id, req.user.company_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json({ message: 'Invoice deleted' });
  } catch (error) {
    next(error);
  }
});

// Get invoice statistics
router.get('/stats/summary', authenticate, async (req, res, next) => {
  try {
    const result = await query(
      `SELECT
        COUNT(*) FILTER (WHERE status = 'draft') as draft_count,
        COUNT(*) FILTER (WHERE status = 'sent') as sent_count,
        COUNT(*) FILTER (WHERE status = 'paid') as paid_count,
        COUNT(*) FILTER (WHERE status = 'overdue') as overdue_count,
        COALESCE(SUM(balance_due) FILTER (WHERE status IN ('sent', 'overdue')), 0) as total_outstanding,
        COALESCE(SUM(total) FILTER (WHERE status = 'paid' AND paid_date >= DATE_TRUNC('month', CURRENT_DATE)), 0) as paid_this_month
      FROM invoices
      WHERE company_id = $1`,
      [req.user.company_id]
    );

    res.json({ stats: result.rows[0] });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
